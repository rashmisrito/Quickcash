const axios = require('axios');
const moment = require('moment');
const excelJS = require("exceljs");
const { mongoose} = require("mongoose");
const playwright = require('playwright');
const { User } = require('../models/user.model');
const { Quote } = require('../models/quote.model');
const { QrCode } = require('../models/qrcode.model');
const { Client } = require("../models/client.model");
const { Invoice } = require('../models/invoice.model');
const { Product } = require("../models/product.model");
const { Account } = require("../models/account.model");
const { Category } = require("../models/category.model");
const { InvoiceRevenue } = require("../models/invoicerevenue.model");
const { InvoiceSetting } = require("../models/invoicesetting.model");
const { TemplateSetting } = require("../models/templatesetting.model");
const { sendMailWithAttachment } = require('../middlewares/mail.middleware');
const { addNotification } = require("../middlewares/notification.middleware");
const { EcommercePayment } = require('../models/Payment/EcommerPayment.model');
var CryptoJS = require("crypto-js");

module.exports = {
  // This is used for add invoice details into the Invoice table
  addInvoice: async(req,res) => {
    const {user,userid,reference,url,othersInfo,invoice_number,invoice_date,due_date,invoice_country,payment_qr_code,currency,recurring,recurring_cycle,productsInfo,discount,discount_type,tax,subTotal,sub_discount,sub_tax,total,note,terms,status,currency_text,type,createdBy} = req.body;
    try {
      if(type == "send") {
        if(invoice_number == "" || invoice_country == "" || productsInfo[0]?.productName == "" || currency == "" || subTotal == "" || invoice_date == "" || due_date == "") {
          return res.status(401).json({
           status: 401,
           message: "Star marked fields are mandatory",
           data: null
          })
        }
      } 

      const ObjectId = mongoose.Types.ObjectId;
      const AccountInfo = await Account.findOne({ user: new ObjectId(user) , currency: currency ? currency : 'USD' });

      if(!AccountInfo) {
        return res.status(401).json({
          status: 401,
          message: "Error while fetching currency account details",
          data: null
        });
      }

      var recurringDate = '';

      if(recurring == "yes") {
        recurringDate = moment().add(recurring_cycle,'days');
      }
  
      const invoice = await Invoice.create({
        user,userid,account: AccountInfo?._id,reference,url,othersInfo,invoice_number,dueAmount: total,invoice_date,due_date,invoice_country,payment_qr_code,currency,recurring,recurring_cycle,productsInfo,discount,discount_type,tax,subTotal,sub_discount,sub_tax,total,note,terms,status,currency_text,createdBy,
        usdtotal: currency == "USD" ? total : await convertCurrencyAmount(currency,"USD",total),recurringDate,savetype:type
      });
  
      if(!invoice) {
       return  res.status(401).json({
        status: 401,
        message: "Error while inserting invoice data",
        data: null
       });
      }

      if(userid) {
        var userDetails = await Client.find({_id: new ObjectId(userid)});
      }
      
      if(payment_qr_code) {
        var qrCodeItem = await QrCode.find({_id: new ObjectId(payment_qr_code)});
      } else {
        var qrCodeItem = '';
      }

      var qrCodeImage = '';
      if(qrCodeItem) {
        qrCodeImage = qrCodeItem[0].image;
      }
  
      if(type == "send") {
        generatePDFfromURL(req?.user?._id,'', 'invoice.pdf', qrCodeImage ? `${process.env.BASE_URL}/qrcode/${qrCodeImage}` : '',invoice_number, invoice,userDetails ? userDetails?.[0]?.address : othersInfo?.[0]?.address,userDetails ? userDetails?.[0].email : othersInfo?.[0]?.email,userDetails? userDetails?.[0].firstName : othersInfo?.[0]?.name, url);
      }

      await addNotification(user,title=`New Invoice has been generated by the ${req?.user?.name} `,tags=`Invoice, ${req?.user?.name}`,message="New Invoice has been added",notifyFrom="user",notifyType="invoice",attachment="",info=`New Invoice has been generated by the ${req?.user?.name} `);
      
      return res.status(200).json({
        status: 201,
        message: "Invoice Data is added Successfully!!!",
        data:invoice
      });

  } catch (error) {
    console.log(error);
    return res.status(500).json({
      status: 500,
      message: "Something went wrong with api",
      data: error
    });
   }
  },
  addInvoiceApi: async(req,res) => {
    const {user,userid,othersInfo,invoice_number,invoice_date,due_date,invoice_country,payment_qr_code,currency,recurring,recurring_cycle,productsInfo,discount,discount_type,tax,subTotal,sub_discount,sub_tax,total,note,terms,status,currency_text,type,createdBy} = req.body;
    try {
      if(type == "send") {
        if(invoice_number == "" || invoice_country == "" || productsInfo[0]?.productName == "" || currency == "" || subTotal == "" || invoice_date == "" || due_date == "") {
          return res.status(401).json({
           status: 401,
           message: "Star marked fields are mandatory",
           data: null
          })
        }
      } 

      const ObjectId = mongoose.Types.ObjectId;
      var reference = Math.floor(Math.random() * 10000000);
      var ciphertext = CryptoJS.AES.encrypt(`${reference}`, 'ganesh').toString();
      const url = `${process.env.BASE_URL2}/invoice-pay?code=${ciphertext}`
      const AccountInfo = await Account.findOne({ user: new ObjectId(user) , currency: currency ? currency : 'USD' });

      if(!AccountInfo) {
        return res.status(401).json({
          status: 401,
          message: "Error while fetching currency account details",
          data: null
        });
      }

      var recurringDate = '';

      if(recurring == "yes") {
        recurringDate = moment().add(recurring_cycle,'days');
      }
  
      const invoice = await Invoice.create({
        user,userid,account: AccountInfo?._id,reference:reference,url,othersInfo,invoice_number,dueAmount: total,invoice_date,due_date,invoice_country,payment_qr_code,currency,recurring,recurring_cycle,productsInfo,discount,discount_type,tax,subTotal,sub_discount,sub_tax,total,note,terms,status,currency_text,createdBy,
        usdtotal: currency == "USD" ? total : await convertCurrencyAmount(currency,"USD",total),recurringDate,savetype:type
      });
  
      if(!invoice) {
       return  res.status(401).json({
        status: 401,
        message: "Error while inserting invoice data",
        data: null
       });
      }

      if(userid) {
        var userDetails = await Client.find({_id: new ObjectId(userid)});
      }
      
      if(payment_qr_code) {
        var qrCodeItem = await QrCode.find({_id: new ObjectId(payment_qr_code)});
      } else {
        var qrCodeItem = '';
      }

      var qrCodeImage = '';
      if(qrCodeItem) {
        qrCodeImage = qrCodeItem[0].image;
      }
  
      if(type == "send") {
        generatePDFfromURL(req?.user?._id,'', 'invoice.pdf', qrCodeImage ? `${process.env.BASE_URL}/qrcode/${qrCodeImage}` : '',invoice_number, invoice,userDetails ? userDetails?.[0]?.address : othersInfo?.[0]?.address,userDetails ? userDetails?.[0].email : othersInfo?.[0]?.email,userDetails? userDetails?.[0].firstName : othersInfo?.[0]?.name, url);
      }

      await addNotification(user,title=`New Invoice has been generated by the ${req?.user?.name} `,tags=`Invoice, ${req?.user?.name}`,message="New Invoice has been added",notifyFrom="user",notifyType="invoice",attachment="",info=`New Invoice has been generated by the ${req?.user?.name} `);
      
      return res.status(200).json({
        status: 201,
        message: "Invoice Data is added Successfully!!!",
        data:invoice
      });

  } catch (error) {
    console.log(error);
    return res.status(500).json({
      status: 500,
      message: "Something went wrong with api",
      data: error
    });
   }
  },
  // This is used for add admin invoice details
  addAdminInvoice: async(req,res) => {
    const {userid,reference,url,othersInfo,invoice_number,invoice_date,due_date,invoice_country,payment_qr_code,currency,recurring,recurring_cycle,productsInfo,discount,discount_type,tax,subTotal,sub_discount,sub_tax,total,note,terms,status,currency_text,type,createdBy} = req.body;
    try {
      if(invoice_number == "" || invoice_country == "" || productsInfo == "" || currency == "" || subTotal == "" || invoice_date == "" || due_date == "") {
        return res.status(401).json({
         status: 401,
         message: "Star marked fields are mandatory",
         data: null
        })
      }
  
     const invoice = await Invoice.create({
      userid,reference,url,othersInfo,invoice_number,invoice_date,due_date,invoice_country,payment_qr_code,currency,recurring,recurring_cycle,productsInfo,discount,discount_type,tax,subTotal,sub_discount,sub_tax,total,note,terms,status,currency_text,createdBy
     })
  
     if(!invoice) {
      return  res.status(401).json({
        status: 401,
        message: "Error while inserting invoice data",
        data: null
      })
     }

     const ObjectId = mongoose.Types.ObjectId;

     if(userid) {
      var userDetails = await User.find({_id: new ObjectId(userid)});
     }
     
     if(payment_qr_code) {
      var qrCodeItem = await QrCode.find({_id: new ObjectId(payment_qr_code)});
     } else {
      var qrCodeItem = '';
     }

     var qrCodeImage = '';
     if(qrCodeItem) {
        qrCodeImage = qrCodeItem[0].image;
     }
 
     if(type == "send") {
       generatePDFfromURL(req?.user?._id,'', 'invoice.pdf', qrCodeImage ? `${process.env.BASE_URL}/qrcode/${qrCodeImage}` : '',invoice_number, invoice,userDetails ? userDetails?.[0]?.address : othersInfo?.[0]?.address,userDetails ? userDetails?.[0].email : othersInfo?.[0]?.email,userDetails? userDetails?.[0].firstName : othersInfo?.[0]?.name, url);
     }
    
    return res.status(200).json({
      status: 201,
      message: "Invoice Data is added Successfully!!!",
      data:invoice
    })

  } catch (error) {
    console.log(error);
    return res.status(500).json({
      status: 500,
      message: "Something went wrong with api",
      data: error
    })
   }
  },
  // This is used for uodate invoice details
  updateInvoice: async(req,res) => {
   const {user,url,userid,invoice_number,othersInfo,invoice_date,due_date,invoice_country,payment_qr_code,currency,recurring,recurring_cycle,productsInfo,discount,discount_type,tax,subTotal,sub_discount,sub_tax,total,note,terms,status,noteandterms,type,currency_text} = req.body;
   const invoice_id = req.params.id;
   var noteVal = note;
   var termsVal = terms;
   
   if(!noteandterms) {
     noteVal = '';
     termsVal = '';
   }
      
   if(!invoice_id) {
    return res.status(401).json({
      status: 401,
      message: "Invoice Id is missing",
      data: null
    })
   }

   const ObjectId = mongoose.Types.ObjectId;

   try {
    if(invoice_number == "" || invoice_country == "" || productsInfo == "" || user == "") {
      return res.status(401).json({
       status: 401,
       message: "Star marked fields are mandatory",
       data: null
      })
    }

    var recurringDate = '';

    if(recurring == "yes") {
      recurringDate = moment().add(recurring_cycle,'days');
    }

    const UpdateData = await Invoice.findByIdAndUpdate(
    {
      _id: new ObjectId(invoice_id)
    },
    {
      user,invoice_number,invoice_date,recurringDate,due_date,dueAmount:total,invoice_country,payment_qr_code,currency,recurring,recurring_cycle,productsInfo,discount,discount_type,tax,subTotal,sub_discount,sub_tax,total,note:noteVal,terms:termsVal,status,currency_text,savetype:type
    },
    {
      new: true,
    })
    
    if(!UpdateData) {
      console.log(UpdateData);
      return  res.status(401).json({
        status:401,
        message: "Error while updating invoice details!",
        data:null
      })
    }

    if(userid) {
      var userDetails = await Client.find({_id: new ObjectId(userid)});
      console.log(userid);
    }

    if(payment_qr_code) {
      var qrCodeItem = await QrCode.find({_id: new ObjectId(payment_qr_code)});
    }

    if(type == "send") {
      generatePDFfromURL(req?.user?._id,'', 'invoice.pdf', qrCodeItem && `${process.env.BASE_URL}/qrcode/${qrCodeItem[0].image}` || '',invoice_number, UpdateData,userDetails ? userDetails?.[0]?.address : othersInfo?.[0]?.address,userDetails ? userDetails?.[0].email : othersInfo?.[0]?.email,userDetails? userDetails?.[0].firstName : othersInfo?.[0]?.name, url);
    }
    
    return res.status(201).json({
      status:201,
      data:UpdateData,
      message: "Invoice details has been updated successfully"
    })

    } catch (error) {
      console.log("Error", error);
      return  res.status(401).json({
        status:401,
        message: error,
        data:null
      })    
    }
  },
  // This is used for update admin invoice details
  updateAdminInvoice: async(req,res) => {
    const {user,url,invoice_number,othersInfo,invoice_date,due_date,invoice_country,payment_qr_code,currency,recurring,recurring_cycle,productsInfo,discount,discount_type,tax,subTotal,sub_discount,sub_tax,total,note,terms,status,noteandterms,type,currency_text} = req.body;
    const invoice_id = req.params.id;
    var noteVal = note;
    var termsVal = terms;
    
    if(!noteandterms) {
      noteVal = '';
      termsVal = '';
    }
       
    if(!invoice_id) {
     return res.status(401).json({
      status: 401,
      message: "Invoice Id is missing",
      data: null
     })
    }
 
    const ObjectId = mongoose.Types.ObjectId;
 
    try {
     if(invoice_number == "" || invoice_country == "" || productsInfo == "" || user == "") {
       return res.status(401).json({
        status: 401,
        message: "Star marked fields are mandatory",
        data: null
       })
     }
 
     const UpdateData = await Invoice.findByIdAndUpdate(
     {
      _id: new ObjectId(invoice_id)
     },
     {
      user,invoice_number,invoice_date,due_date,invoice_country,payment_qr_code,currency,productsInfo,discount,discount_type,tax,subTotal,sub_discount,sub_tax,total,note:noteVal,terms:termsVal,status,currency_text
     },
     {
      new: true,
     });
     
     if(!UpdateData) {
       console.log(UpdateData);
       return  res.status(401).json({
        status:401,
        message: "Error while updating invoice details!",
        data:null
       })
     }
 
     if(user) {
      var userDetails = await User.find({_id: new ObjectId(user)});
     } 

     if(payment_qr_code) {
       var qrCodeItem = await QrCode.find({_id: new ObjectId(payment_qr_code)});
     }
 
     if(type == "send") {
       generatePDFfromURL(req?.user?._id,'', 'invoice.pdf', qrCodeItem && `${process.env.BASE_URL}/qrcode/${qrCodeItem[0].image}` || '',invoice_number, invoice,userDetails ? userDetails?.[0]?.address : othersInfo?.[0]?.address,userDetails ? userDetails?.[0].email : othersInfo?.[0]?.email,userDetails? userDetails?.[0].firstName : othersInfo?.[0]?.name, url);
       // generatePDFfromURL(req?.user?._id,'', 'invoice.pdf', qrCodeItem && `${process.env.BASE_URL}qrcode/${qrCodeItem[0].image}` || '',invoice_number, UpdateData,userDetails,userDetails[0].email,userDetails[0].name,"");
     }
     
     return res.status(201).json({
       status:201,
       data:UpdateData,
       message: "Invoice details has been updated successfully"
     })
 
     } catch (error) {
       console.log("Error", error);
       return  res.status(401).json({
        status:401,
        message: error,
        data:null
       })    
     }
  },
  // This is used for get invoice list
  invoiceList: async(req,res) => {
  
    const user_id = req.params.id; 
    const status = req.query.status || '';
    const recurring = req.query.recurring || '';
    const ObjectId = mongoose.Types.ObjectId;

    try {
     if(!user_id) {
      return res.status(402).json({
        status: 402,
        message: "User Id is missing",
        data: null
      })
     }

    if(status && recurring) {
      var details = await Invoice.find(
        { user: new ObjectId(user_id),
         $and: [
          {'status' : status},
          {'recurring': recurring}
      ]}
    ).sort({ updatedAt: -1 });
    } else if(status) {
      var details = await Invoice.find(
        { user: new ObjectId(user_id),
         $or: [
          {'status' : status}
        ]}
      ).sort({ updatedAt: -1 });
    } else if(recurring) {
      var details = await Invoice.find(
        { user: new ObjectId(user_id),
         $or: [
          {'recurring': recurring}
        ]}
      ).sort({ updatedAt: -1 });
    } else {
      var details = await Invoice.find(
        { user: new ObjectId(user_id),
         $or: [{
          'status' : { $ne: status }
        }] }
      ).sort({ updatedAt: -1 });
    }

    if(!details) {
      return res.status(402).json({
        status: 402,
        message: "Error while fetching invoice list!!!",
        data: null
      })
    }
 
    return res.status(201).json({
      status:201,
      message: "Invoice Data list is Successfully fetched",
      data: details
    });

   } catch (error) {
      console.log(error);
      return res.status(500).json({
        status: 500,
        message: "Error while fetching invoice data list!!!",
        data: error
      });
    }
  },
  // This is used for admin invoice details
  AdmininvoiceList: async(req,res) => {
  
    const user_id = req.params.id; 
    const status = req.query.status || '';
    const recurring = req.query.recurring || '';
    const ObjectId = mongoose.Types.ObjectId;

    try {

    if(status && recurring) {
      var details = await Invoice.find(
        {'status' : status},
        {'recurring': recurring}
      );
    } else if(status) {
      var details = await Invoice.find(
        {'status' : status}
      );
    } else if(recurring) {
      var details = await Invoice.find(
        {'recurring': recurring}
      );
    } else {
      var details = await Invoice.find({
        'status' : { $ne: status }
      }  
      );
    }

    if(!details) {
      return res.status(402).json({
        status: 402,
        message: "Error while fetching invoice list!!!",
        data: null
      })
    }

    return res.status(201).json({
      status:201,
      message: "Invoice Data list is Successfully fetched",
      data: details
    })
   } catch (error) {
      return res.status(500).json({
        status: 500,
        message: "Error while fetching invoice data list!!!",
        data: error
      })
    }
  },
  // This is used for fetch invoice details
  invoiceById: async(req,res) => {
    try {
      const user_id = req.params.id;
   
      if(!user_id) {
        return res.status(402).json({
          status: 402,
          message: "User Id is missing",
          data: null
        })
      }
  
      const ObjectId = mongoose.Types.ObjectId;
      const details = await Invoice.aggregate([
      {
        $match: {
          _id: new ObjectId(user_id)
        }
      },
      {
        $lookup: {
          "from": "users",
          "localField": "user",
          "foreignField": "_id",
          "as": "userDetails"
        }
      },
      {
        $project: {
        _id:1,
        user:1,
        invoice_number:1,
        invoice_date:1,
        due_date:1,
        status:1,
        othersInfo:1,
        url:1,
        userid:1,
        invoice_country:1,
        payment_qr_code:1,
        currency_text:1,
        currency:1,
        recurring:1,
        recurring_cycle:1,
        productsInfo:1,
        discount:1,
        discount_type:1,
        tax:1,
        subTotal:1,
        sub_discount:1,
        sub_tax:1,
        total:1,
        createdAt:1,
        createdBy:1,
        dueAmount:1,
        note:1,
        terms:1,
        userDetails: {
        _id: 1,
        name: 1,
        email: 1,
        mobile: 1,      
        address: 1,
        city: 1,
        country: 1,
        defaultCurrency: 1,
        status:1
      }
    }
   },
   ])

   if(!details) {
     return res.status(402).json({
      status: 402,
      message: "Error while fetching invoice details!!!",
      data: null
     })
   }
  
  return res.status(201).json({
    status:201,
    message: "Invoice details is Successfully fetched",
    data: details
  })
  } catch (error) {
    console.log(error); 
    return res.status(500).json({
     status:500,
     message: "Something went wrong with api",
     data: error
   })
  }
  },
  // This is used for get transaction by their id
  transactionsById: async(req,res) => {
    try {
      const invoice_id = req.params.id;
   
      if(!invoice_id) {
        return res.status(402).json({
          status: 402,
          message: "Invoice Id is missing",
          data: null
        })
      }
  
      const ObjectId = mongoose.Types.ObjectId;
      //const details = await InvoiceOrders.find({invoice: new ObjectId(invoice_id)});
      const details = await InvoiceRevenue.find({invoice: new ObjectId(invoice_id)})
      if(!details) {
        return res.status(402).json({
          status: 402,
          message: "Error while fetching invoice details!!!",
          data: null
        })
      }
      
      return res.status(201).json({
        status:201,
        message: "Invoice details is Successfully fetched",
        data: details
      })
      } catch (error) {
        console.log(error); 
        return res.status(500).json({
        status:500,
        message: "Something went wrong with api",
        data: error
      })
   }
  },
  // This is used for generate inv invoice details
  generateInv: async(req,res) => {

    const invoiceSettings = await InvoiceSetting.findOne({ user: req?.user?._id});

    const invoiceProducts = await Product.find({ user: req?.user?._id });

    if(!invoiceSettings) {
      return res.status(500).json({
        status: 500,
        message: "Getting error while fetching Invoice Settings details",
        data: null
      });
    }

    if(!invoiceProducts) {
      return res.status(500).json({
        status: 500,
        message: "Getting error while fetching Invoice product details",
        data: null
      });
    }

    var valString = invoiceSettings?.prefix || '';
    var length = 4;
    for (var s=''; s.length < length; s += 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'.charAt(Math.random()*62|0)) {
      var milliseconds = Math.floor(Math.random() * 99999);
      valString = valString + s;
    }

    if(valString) {
      return res.status(201).json({
        status: 201,
        message: "Invoice Number is generated and sent",
        data: (valString+milliseconds).toUpperCase(),
        productData:invoiceProducts
      });
    }
  },
  // This is used for add invoice details (Mobile API)
  generateInvapi: async(req,res) => {

    const invoiceSettings = await InvoiceSetting.findOne({ user: req?.user?._id});

    if(!invoiceSettings) {
      return res.status(500).json({
        status: 500,
        message: "Getting error while fetching Invoice Settings details",
        data: null
      });
    }

    var valString = invoiceSettings?.prefix || '';
    var length = 4;
    for (var s=''; s.length < length; s += 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'.charAt(Math.random()*62|0)) {
      var milliseconds = Math.floor(Math.random() * 99999);
      valString = valString + s;
    }

    if(valString) {
      return res.status(201).json({
        status: 201,
        message: "Invoice Number is generated and sent",
        invoiceid: (valString+milliseconds).toUpperCase()
      });
    }
  },
  // This is used for delete invoice data by their id
  deleteInvoice: async(req,res) => {
    try {   
      const invoice_id = req.params.id;   
      if(invoice_id == "") {
        return res.status(401).json({
          status: 401,
          message: "Invoice Id is missing",
          data: null
        })
      }
      const deletedData = await Invoice.deleteOne({_id: invoice_id});
      if(!deletedData) {
        return  res.status(401).json({
          status:401,
          message: "Error while updating invoice details!",
          data:null
        })
      }
      return res.status(201).json({
        status:201,
        message: "Invoice data has been deleted successfully"
      })
    } catch (error) {
        console.log("Error", error);
        return  res.status(401).json({
          status:401,
          message: error,
          data:null
        })    
    }
  },
  // This is used for export excel invoice details
  exportExcelForInvoice: async(req,res) => {
    const workbook = new excelJS.Workbook();  // Create a new workbook
    const worksheet = workbook.addWorksheet("Invoices"); // New Worksheet
    const path = "./uploads";  // Path to download excel
    // Column for data in excel. key must match data key
    worksheet.columns = [
    { header: "S no.", key: "s_no", width: 10 }, 
    { header: "Invoice Number", key: "invoice_number", width: 20 },
    { header: "Invoice Date", key: "invoice_date", width: 20 },
    { header: "Due Date", key: "due_date", width: 20 },
    { header: "Amount", key: "total", width: 20 },
    { header: "Status", key: "status", width: 20 },
    ];

    const invoiceData = await Invoice.find({user: req.params.id});

    // Looping through User data
    let counter = 1;
    invoiceData.forEach((user) => {
      user.s_no = counter;
      worksheet.addRow(user); // Add data in worksheet
      counter++;
    });

    // Making first line in excel bold
      worksheet.getRow(1).eachCell((cell) => {
        cell.font = { bold: true };
      });
      try {
        const data = await workbook.xlsx.writeFile(`${path}/InvoiceList.xlsx`)
        .then(() => {
          res.send({
            status: "success",
            message: "file successfully downloaded",
            path: `${path}/InvoiceList.xlsx`,
          });
        });
      } catch (err) {
          res.send({
          status: "error",
          message: "Something went wrong",
        });
      }
  },
  // This is used for fetching invoice setting details
  IsAvailableInvoiceSettings : async(req,res) => {

    const id = req?.params?.id;

    if(!id) {
      return res.status(401).json({
        status: 401,
        message: "User Id is missing",
        data: null
      });
    }

    try {
      const checkSettings = await InvoiceSetting.findOne({user: req?.user?._id});

      return res.status(201).json({
        status: 201,
        message: "Invoice Settings Data!",
        data: checkSettings
      });

    } catch (error) {
      console.log(error);
      return res.status(500).json({
        status: 500,
        message: "Something went wrong!",
        data: null
      });
    }
  },
  // This is used for send reminder to invoice user
  reminderInvoiceToUser : async (req,res) => {
    try {
      const invoice_number = req.params.id;
      const ObjectId = mongoose.Types.ObjectId;
      if(invoice_number == "") {
        return res.status(401).json({
          status: 401,
          message: "Invoice Number is missing",
          data: null
        })
      }

      const invoiceDetails = await Invoice.aggregate([
      {
        $match: {
          _id: new ObjectId(invoice_number)
        }
      },
      {
        $lookup: {
          "from": "users",
          "localField": "user",
          "foreignField": "_id",
          "as": "userDetails"
        }
      },
      {
        $lookup: {
          "from": "qrcodes",
          "localField": "user",
          "foreignField": "user",
          "as": "qrcodeDetails"
        }
      },
      {
        $lookup: {
          "from": "invoicesettings",
          "localField": "user",
          "foreignField": "user",
          "as": "settingsDetails"
        }
      },
      {
        $project: {
        _id:1,
        user:1,
        invoice_number:1,
        invoice_date:1,
        paidAmount:1,
        due_date:1,
        status:1,
        transactionStatus:1,
        othersInfo:1,
        url:1,
        userid:1,
        invoice_country:1,
        payment_qr_code:1,
        currency_text:1,
        currency:1,
        recurring:1,
        recurring_cycle:1,
        productsInfo:1,
        discount:1,
        discount_type:1,
        tax:1,
        subTotal:1,
        sub_discount:1,
        sub_tax:1,
        total:1,
        createdAt:1,
        createdBy:1,
        dueAmount:1,
        note:1,
        terms:1,
        userDetails: {
        _id: 1,
        name: 1,
        email: 1,
        mobile: 1,      
        address: 1,
        state:1,
        postalcode:1,
        city: 1,
        country: 1,
        defaultCurrency: 1,
        status:1
       },
       qrcodeDetails: {
       title:1,
       image:1
       },
       settingsDetails: {
        user:1,
        invoice_country:1,
        company_name:1,
        mobile:1,
        state:1,
        city:1,
        zipcode:1,
        address:1,
        logo:1,
        regardstext:1
       }
      }
      },
      ]);

      if(!invoiceDetails) {
        return  res.status(401).json({
          status:401,
          message: "Invoice Doesn't exists",
          data:null
        });
      }

      if(invoiceDetails?.[0]?.userid) {
        var userDetails = await Client.find({_id: new ObjectId(invoiceDetails?.[0]?.userid)});
      }  

      await generatePDFfromURL(req?.user?._id,'', 'invoice.pdf', invoiceDetails[0]?.qrcodeDetails?.[0]?.image && `${process.env.BASE_URL}/qrcode/${invoiceDetails[0]?.qrcodeDetails?.[0]?.image}` || '',invoiceDetails[0]?.invoice_number, invoiceDetails[0],userDetails ? userDetails?.[0]?.address : invoiceDetails?.[0]?.othersInfo?.[0]?.address,userDetails ? userDetails?.[0].email : invoiceDetails?.[0]?.othersInfo?.[0]?.email,userDetails? userDetails?.[0].firstName : invoiceDetails?.[0]?.othersInfo?.[0]?.name, invoiceDetails?.[0]?.url);
      
      return res.status(201).json({
        status:201,
        message: "Reminder has been sent"
      });

    } catch (error) {
      console.log("error", error);
      return  res.status(401).json({
        status:401,
        message: "Error while send reminder!",
        data:null
      });
    }
  },
  // This is used for get invoice details by their invoice number
  getInvoiceInfoByInvoiceNumber: async (req,res) => {
    
    const invoice_number = req?.params?.id;

    try {
      
      const getDetails = await Invoice.findOne({ invoice_number: invoice_number });
        
      if(!getDetails) {
        return res.status(401).json({
          status:401,
          message: "Error while fetching invoice details!",
          data:getDetails
        });
      }
      
      return res.status(201).json({
        status: 201,
        message: "Successfully Fetched details",
        data: getDetails
      });

    } catch (error) {
      console.log(error);
      return res.status(500).json({
        status: 500,
        message: "Something went wrong with unpaid invoice api",
        data: []
      });
    }

  },
  // This is used for fetch invoice dashboard details
  invoiceDashboard: async (req,res) => {

    const userId = req?.user._id;
    const ObjectId = mongoose.Types.ObjectId;

    if(!userId) {
      return res.status(401).json({
        status:401,
        message: "User Id is missing!",
        data:null
      });
    }

    const totalClients  = await Client.find({ user: new ObjectId(userId) });
    const totalInvoice  = await Invoice.find({ user: new ObjectId(userId) });
    const totalProducts = await Product.find({ user: new ObjectId(userId) });
    const totalCategory = await Category.find({ user: new ObjectId(userId) });
    const totalPaid     = await InvoiceRevenue.find({ user: new ObjectId(userId) });

    if(!totalInvoice) {
      return res.status(401).json({
        status:401,
        message: "Getting error while fetching invoice details!",
        data:null
      });
    }

    var totalPaidValue = 0;
    if(totalPaid) {
      totalPaid?.map((item) => {
        totalPaidValue = parseFloat(totalPaidValue) + parseFloat(item?.convertAmount);
      });
    }

    let currentDate = new Date().toISOString().replace('T', ' ').substring(0, 10);

    var totalUnpaid = 0;
    var totalOverdue = 0;
    var totalInvoiceValue = 0;
    totalInvoice?.map((item) => {
      if(item?.usdtotal > 0) {
        totalUnpaid = parseFloat(totalUnpaid) + parseFloat(item?.usdtotal);
      }
      if(currentDate > item?.due_date) {
        totalOverdue = parseFloat(totalOverdue) + parseFloat(item?.dueAmount);
      }
      totalInvoiceValue = parseFloat(totalInvoiceValue) + parseFloat(item?.usdtotal);
    });

    totalUnpaid = Math.abs(totalUnpaid - totalPaidValue);

    const datas = {
      "totalPaid": parseFloat(totalPaidValue).toFixed(2),
      "totalUnpaid": totalUnpaid,
      "totalOverdue": parseFloat(totalOverdue).toFixed(2),
      "totalProducts": totalProducts?.length,
      "totalClients": totalClients?.length,
      "totalCategory": totalCategory?.length,
      "totalInvoice": totalInvoiceValue
    }

    return res.status(201).json({
      status: 201,
      message: "Dashboard Invoice are fetched successfully!!!",
      data: datas
    });
 
  },
  // This is used to filter invoice dashborad results through their parameters
  filterinvoiceDashboard: async (req,res) => {

    // This Week
    var startOfWeek = moment().startOf('week').format('YYYY-MM-DD');
    var endOfWeek   = moment().endOf('week').format('YYYY-MM-DD');

    // Last Week
    var lastStartOfWeek = moment().startOf('week').subtract(7,'days').format('YYYY-MM-DD');
    var lastEndofWeek = moment().endOf('week').subtract(7, 'days').format('YYYY-MM-DD');

    // This Month
    var startOfMonth = moment().clone().startOf('month').format('YYYY-MM-DD');
    var endOfMonth   = moment().clone().endOf('month').format('YYYY-MM-DD');

    // Last Month
    var lastStartOfMonth = moment().subtract(1, 'months').startOf('month').format('YYYY-MM-DD');
    var lastEndofMonth = moment().subtract(1, 'months').endOf('month').format('YYYY-MM-DD');

    const userId = req?.user._id;
    const ObjectId = mongoose.Types.ObjectId;
    const filter = req?.query?.filter || '';

    if(!userId) {
      return res.status(401).json({
        status:401,
        message: "User Id is missing!",
        data:null
      });
    }

    var fdate1 = new Date().toISOString().replace('T', ' ').substring(0, 10);
    var fdate2 = new Date().toISOString().replace('T', ' ').substring(0, 10);

    if(filter) {
      if(filter == "Today") {
        fdate1 = new Date().toISOString().replace('T', ' ').substring(0, 10);
        fdate2 = new Date().toISOString().replace('T', ' ').substring(0, 10);
      } else if(filter == "This_Week") {
        fdate1 = startOfWeek;
        fdate2 = endOfWeek;
      } else if(filter == "Last_Week") {
        fdate1 = lastStartOfWeek;
        fdate2 = lastEndofWeek;
      } else if(filter == "This_Month") {
        fdate1 = startOfMonth;
        fdate2 = endOfMonth;
      } else if(filter == "Last_Month") {
        fdate1 = lastStartOfMonth;
        fdate2 = lastEndofMonth;
      } else if(filter == "Custom") {
        fdate1 = startOfWeek;
        fdate2 = endOfWeek;
      } else {
        fdate1 = new Date().toISOString().replace('T', ' ').substring(0, 10);
        fdate2 = new Date().toISOString().replace('T', ' ').substring(0, 10);
      }
    }

    const dates = dateRange(fdate1, fdate2);

    // const totalPaid = await InvoiceRevenue.aggregate([
    // {
    //   $match: {
    //     user: new ObjectId(userId),
    //     createdAt: {
    //       $gte: new Date(fdate1),
    //       $lte: moment.utc(fdate2).endOf('day').toDate()
    //     }  
    //   }
    // },
    // {
    //   $group: { 
    //    '_id': '$dateadded',
    //    'count': { '$sum': 1 },
    //    'total': { $sum: "$convertAmount" }
    //   }, 
    // },
    // // Third pipeline step
    // {  
    //   '$group': {
    //   '_id': null,
    //   'counts': {
    //     '$push': {
    //       'k': '$_id',
    //       'v': {
    //         'total': '$total'
    //       }
    //     }
    //   }
    //  } 
    // },
    // // Fourth pipeline step
    // { 
    //   '$replaceRoot': {
    //    'newRoot': { '$arrayToObject': '$counts' }
    //   }}
    // ]);

    // console.log(totalPaid);
    // var keyArray = [];
    // if(totalPaid[0]) {
    //   Object.entries(totalPaid[0]).map(([key, value]) => {
    //     keyArray.push({
    //       key: key,
    //       value: value?.total
    //     }
    //     );
    //   });
    // }

    // console.log("KeyArray", keyArray);
    // console.log("paidArray", totalPaid[0]);


    var newArrayLabelAndValues = [];
    var i = 0;
    if(dates) {
      for (const element of dates) {
        var jk = await InvoiceRevenue.find({ dateadded: element });
        var summ = 0;
        if(jk) {
          jk?.map(item => {
            summ = summ + item?.convertAmount;
          })
        }
        newArrayLabelAndValues.push({
          label: element,
          value: summ
        })
      }
    }
  
    // if(!totalPaid) {
    //   return res.status(401).json({
    //     status:401,
    //     message: "getting error while fetching invoice details!",
    //     data:null
    //   });
    // }

    // var jk = [];
    // if(dates) {
    //   for (const element of dates) {
    //     const totalPaid2 = await InvoiceRevenue.find(
    //     {
    //       user: new ObjectId(userId),
    //       createdAt: {
    //         $gte: new Date(element),
    //         $lte: moment.utc(element).endOf('day').toDate()
    //       }
    //     }
    //     )
    //     jk.push({
    //       element,totalPaid2
    //     })
    //   }
    // }

    return res.status(201).json({
      status: 201,
      message: "Dashboard details are fetched successfully!!!",
      range: dates,
      labelValue:newArrayLabelAndValues
    });

  },
  // This is used for fetch quote dashboard details
  quoteDashboard: async (req,res) => {

    const userId = req?.user._id;
    const ObjectId = mongoose.Types.ObjectId;

    if(!userId) {
      return res.status(401).json({
        status:401,
        message: "User Id is missing!",
        data:null
      });
    }

    const quoteData = await Quote.find({ user: new ObjectId(userId) });

    if(!quoteData) {
      return res.status(401).json({
        status:401,
        message: "Getting error while fetching invoice details!",
        data:null
      });
    }

    var totalConverted = 0;
    var totalAccept    = 0;
    var totalReject    = 0;

    quoteData?.map(item => {
      if(item?.status == "converted") {
        totalConverted = totalConverted + 1;
      } else if(item?.status == "accept") {
        totalAccept = totalAccept + 1;
      } else if(item?.status == "reject") {
        totalReject = totalReject + 1;
      }
    })

    const datas = {
      "totalQuote": quoteData?.length,
      "totalConverted": totalConverted,
      "totalAccept": totalAccept,
      "totalReject": totalReject
    }

    return res.status(201).json({
      status: 201,
      message: "Dashboard Quote details are fetched successfully!!!",
      data: datas
    });
 
  },
  // This is used for filter quote dashboard details
  filterQuoteDashboard: async (req,res) => {

    // This Week
    var startOfWeek = moment().startOf('week').format('YYYY-MM-DD');
    var endOfWeek   = moment().endOf('week').format('YYYY-MM-DD');

    // Last Week
    var lastStartOfWeek = moment().startOf('week').subtract(7,'days').format('YYYY-MM-DD');
    var lastEndofWeek = moment().endOf('week').subtract(7, 'days').format('YYYY-MM-DD');

    // This Month
    var startOfMonth = moment().clone().startOf('month').format('YYYY-MM-DD');
    var endOfMonth   = moment().clone().endOf('month').format('YYYY-MM-DD');

    // Last Month
    var lastStartOfMonth = moment().subtract(1, 'months').startOf('month').format('YYYY-MM-DD');
    var lastEndofMonth = moment().subtract(1, 'months').endOf('month').format('YYYY-MM-DD');

    const userId = req?.user._id;
    const ObjectId = mongoose.Types.ObjectId;
    const filter = req?.query?.filter || '';

    if(!userId) {
      return res.status(401).json({
        status:401,
        message: "User Id is missing!",
        data:null
      });
    }

    var fdate1 = new Date().toISOString().replace('T', ' ').substring(0, 10);
    var fdate2 = new Date().toISOString().replace('T', ' ').substring(0, 10);

    if(filter) {
      if(filter == "Today") {
        fdate1 = new Date().toISOString().replace('T', ' ').substring(0, 10);
        fdate2 = new Date().toISOString().replace('T', ' ').substring(0, 10);
      } else if(filter == "This_Week") {
        fdate1 = startOfWeek;
        fdate2 = endOfWeek;
      } else if(filter == "Last_Week") {
        fdate1 = lastStartOfWeek;
        fdate2 = lastEndofWeek;
      } else if(filter == "This_Month") {
        fdate1 = startOfMonth;
        fdate2 = endOfMonth;
      } else if(filter == "Last_Month") {
        fdate1 = lastStartOfMonth;
        fdate2 = lastEndofMonth;
      } else if(filter == "Custom") {
        fdate1 = startOfWeek;
        fdate2 = endOfWeek;
      } else {
        fdate1 = new Date().toISOString().replace('T', ' ').substring(0, 10);
        fdate2 = new Date().toISOString().replace('T', ' ').substring(0, 10);
      }
    }

    const dates = dateRange(fdate1, fdate2);

    const totalPaid = await Quote.aggregate([
    {
      $match: {
        user: new ObjectId(userId),
        createdAt: {
          $gte: new Date(fdate1),
          $lte: moment.utc(fdate2).endOf('day').toDate()
        }  
      }
    },
    {
      $group: { 
       '_id': { '$dateToString': { 'format': '%Y-%m-%d', 'date': '$createdAt' } },
       'count': { '$sum': 1 },
       'total': { $sum: "$total" }
      }, 
    },
    // Third pipeline step
    {  
      '$group': {
      '_id': null,
      'counts': {
        '$push': {
          'k': '$_id',
          'v': {
            'total': '$total'
          }
        }
      }
     } 
    },
    // Fourth pipeline step
    { 
      '$replaceRoot': {
       'newRoot': { '$arrayToObject': '$counts' }
      }}
    ]);

    if(!totalPaid) {
      return res.status(401).json({
        status:401,
        message: "getting error while fetching quote details!",
        data:null
      });
    }

    var jk = [];
    if(dates) {
      for (const element of dates) {
        const totalPaid2 = await Quote.find(
        {
          user: new ObjectId(userId),
          createdAt: {
            $gte: new Date(element),
            $lte: moment.utc(element).endOf('day').toDate()
          }
        }
        )
        jk.push({
          element,totalPaid2
        })
      }
    }

    return res.status(201).json({
      status: 201,
      message: "Dashboard details are fetched successfully!!!",
      data: totalPaid[0],
      range: dates,
      jk:jk
    });

  },
  // This is used for get invoice transactions details by their invoice number
  getInvoiceTransactionByInvoiceNumber: async (req,res) => {
    const invoice_id = req?.params?.invoice_id;
    try {
      
      const getDetails = await EcommercePayment.findOne({ invoice: invoice_id });
        
      if(!getDetails) {
        return res.status(201).json({
          status:201,
          message: "No data found!",
          data:null
        });
      }
      
      return res.status(201).json({
        status: 201,
        message: "Successfully Fetched details",
        data: getDetails
      });

    } catch (error) {
      console.log(error);
      return res.status(500).json({
        status: 500,
        message: "Something went wrong with unpaid invoice api",
        data: []
      });
    }
  }
}

function dateRange(startDate, endDate, steps = 1) {
  const dateArray = [];
  let currentDate = new Date(startDate);

  while (currentDate <= new Date(endDate)) {
    dateArray.push(moment(currentDate).format('YYYY-MM-DD'));
    // Use UTC date to prevent problems with time zones and DST
    currentDate.setUTCDate(currentDate.getUTCDate() + steps);
  }

  return dateArray;
}


// This function is used in Invoice Section in order to create a pdf file for invoice.

// here,
// Setting_id means invoice setting table of user based details
// qrCode means Payment QR Code id
// inv means invoice number
// item means invoice details array
// address means any other address of user
// email means any other email address of user
// name means any other name of user

async function generatePDFfromURL(setting_id,url, outputPath,qrCode,inv,item,address,email,name,urll) {

  var printFileName = '';
  if(item.invoice_country == "Default") {
    printFileName = 'Default/defaultPrint.ejs';
  } else if(item.invoice_country == "New_York") {
    printFileName = 'NewYork/newyorkprint.ejs';
  } else if(item.invoice_country == "Toronto") {
    printFileName = 'Toronto/torontoprint.ejs';
  } else if(item.invoice_country == "Rio") {
    printFileName = 'Rio/rioprint.ejs';
  } else if(item.invoice_country == "London") {
    printFileName = 'London/londonprint.ejs';
  } else if(item.invoice_country == "Istanbul") {
    printFileName = 'Istanbul/istanbulprint.ejs';
  } else if(item.invoice_country == "Mumbai") {
    printFileName = 'Mumbai/mumbaiprint.ejs';
  } else if(item.invoice_country == "Hong_Kong") {
    printFileName = 'HongKong/hongkongprint.ejs';
  } else if(item.invoice_country == "Tokyo") {
    printFileName = 'Tokyo/tokyoprint.ejs';
  } else if(item.invoice_country == "Paris") {
    printFileName = 'Paris/parisprint.ejs';
  } else {
    printFileName = 'Default/defaultPrint.ejs';
  }

  const invoiceData = await InvoiceSetting.find({user: setting_id});

  const printColor = await TemplateSetting.find({invoice_country: item.invoice_country, user: setting_id});

  var byDefaultPrintColor = '';
  if(printColor.length > 0) {
    byDefaultPrintColor = printColor[0]?.color;
  } else {
    byDefaultPrintColor = "#000000";
  }

  var invcsettingData = [];
  if(invoiceData.length > 0) {
    invcsettingData = invoiceData;
  } else {
    invcsettingData = [];
  }

  const logoInvoice = `${process.env.BASE_URL}/setting/${invoiceData?.[0]?.user}/${invoiceData?.[0]?.logo}`;

  try {
   const ejs = require("ejs");
   ejs.renderFile(__dirname.replace('\controllers','') + `/views/InvoiceTemplates/${printFileName}`, {invoiceData:invcsettingData,byDefaultPrintColor,qrCode,item, address , email , name, inv, logoInvoice}, async function (err, data) {
   if (err) {
    console.log("error in Invoice Template file: ",err);
   } else {
     const path = require('path');
     const fs = require('fs');
     const folderName = `public/invoices/${inv}`;
     try {
      if (!fs.existsSync(folderName)) {
       fs.mkdirSync(folderName);
      }
     } catch (err) {
       console.error("error",err);
     }
  
    const pathInvoice = __dirname.replace("src","public/invoices");
    const pdfPath = path.resolve(pathInvoice, inv+`/Invoice_${inv}.pdf`);
    console.log("Invoice pdf path is ", pdfPath);
     
    const browser = await playwright.chromium.launch();
    const page = await browser.newPage();
    await page.setContent(data);
    await page.pdf({ path: pdfPath.replace("controllers","") });
    console.log('PDF generated successfully');
    await browser.close();
    const htmlBody = `Dear ${name} , <br/><br/> Please find herewith below the Invoice <br /><br /> Quick Cash has sent you a invoice payment link , click on button<br /><br /><br /><a href="${urll}" style="margin-bottom:2px; text-decoration: none; cursor: pointer; font-size:16px; background-color: black; color: white; padding: 12px;border-radius: 12px;">Proceed to Pay</a> <br/><br/><br/> Regards <br/> Quick Cash`;
    const subject = "Invoice!!!"
    const emailSent = sendMailWithAttachment(email,subject,htmlBody,pdfPath.replace("controllers",""),title=`Invoice_${inv}.pdf`);
    if(emailSent)
      console.log("Invoice pdf has been sent");
    else 
      console.log("waiting...");
    }
   });
  } catch (error) {
    console.error('Error fetching URL:', error);
  }
}

// This function is used to convert amount of one currency to other currency

// For example: - 

// If we want to convert USD to INR then we will pass argument like 
// From = USD
// To = INR
// Amount = 10000

// So, it will return converted amount in INR

async function convertCurrencyAmount(from,to,amount) {
  if(from && to && amount) {
    const options = {
      method: 'GET',
      url: 'https://currency-converter18.p.rapidapi.com/api/v1/convert',
      params: {
        from: from,
        to: to,
        amount: amount
      },
      headers: {
       'X-RapidAPI-Key': process.env.RAPID_API_KEY,
       'X-RapidAPI-Host': process.env.RAPID_API_HOST
      }
    };
     
    try {
      const response = await axios.request(options);
      if(response.data.success) {
        console.log("from", from,to,amount);
        return response.data.result.convertedAmount;
      } else {
        return 0;
      }
    } catch (error) {
      console.error(error);
    }
  }
}
